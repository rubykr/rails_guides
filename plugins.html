<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ruby on Rails Guides: The Basics of Creating Rails Plugins</title>

<link rel="stylesheet" type="text/css" href="stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="stylesheets/syntaxhighlighter/shThemeRailsGuides.css" />
</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://rubyonrails.org/">rubyonrails.org:</a> </strong>
      <a href="http://rubyonrails.org/">Overview</a> |
      <a href="http://rubyonrails.org/download">Download</a> |
      <a href="http://rubyonrails.org/deploy">Deploy</a> |
      <a href="http://rails.lighthouseapp.com/projects/8994-ruby-on-rails/overview">Code</a> |
      <a href="http://rubyonrails.org/screencasts">Screencasts</a> |
      <a href="http://rubyonrails.org/documentation">Documentation</a> |
      <a href="http://rubyonrails.org/ecosystem">Ecosystem</a> |
      <a href="http://rubyonrails.org/community">Community</a> |
      <a href="http://weblog.rubyonrails.org/">Blog</a>
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Return to home page">Guides.rubyonrails.org</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">홈</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">목차</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>시작</dt>
              <dd><a href="getting_started.html">레일즈 시작하기</a></dd>
              <dt>모델(Models)</dt>
              <dd><a href="migrations.html">레일즈 데이터베이스 마이그레이션</a></dd>
              <dd><a href="active_record_validations_callbacks.html">액티브 레코드 데이터 검증(Validation)과 Callback(콜백)</a></dd>
              <dd><a href="association_basics.html">액티브 레코드 Association(관계)</a></dd>
              <dd><a href="active_record_querying.html">액티브 레코드 쿼리 인터페이스</a></dd>
              <dt>뷰(Views)</dt>
              <dd><a href="layouts_and_rendering.html">레이아웃(Layouts)과 렌더링(Rendering)</a></dd>
              <dd><a href="form_helpers.html">액션 뷰 폼 핼퍼(Action View Form Helpers)</a></dd>
              <dt>컨트롤러(Controllers)</dt>
              <dd><a href="action_controller_overview.html">액션 컨트롤러 둘러보기</a></dd>
              <dd><a href="routing.html">외부 요청에 대한 레일즈 라우팅</a></dd>
            </dl>
            <dl class="R">
              <dt>심화내용</dt>
              <dd><a href="active_support_core_extensions.html">액티브 서포트(Active Support) 확장(Core Extensions)</a></dd>
              <dd><a href="i18n.html">레일즈 국제화I(nternationalization) API</a></dd>
              <dd><a href="action_mailer_basics.html">액션 메일러의 기본</a></dd>
              <dd><a href="testing.html">레일즈 어플리케이션 테스트하기</a></dd>
              <dd><a href="security.html">레일즈 어플리케이션의 보안</a></dd>
              <dd><a href="debugging_rails_applications.html">레일즈 어플리케이션 디버깅</a></dd>
              <dd><a href="performance_testing.html">레일즈 어플리케이션 성능 테스트하기</a></dd>
              <dd><a href="configuring.html">레일즈 어플리케이션 설정</a></dd>
              <dd><a href="command_line.html">레일즈 커멘드라인 도구와 Rake 테스크</a></dd>
              <dd><a href="caching_with_rails.html">레일즈를 이용한 캐싱</a></dd>

              <dt>레일즈 확장하기(Extending Rails)</dt>
              <dd><a href="plugins.html">레일즈 플러그인 작성의 기본</a></dd>
              <dd><a href="rails_on_rack.html">렉 위의 레일즈(Rails on Rack)</a></dd>
              <dd><a href="generators.html">레일즈 제너레이터(Generator) 제작과 수정</a></dd>

              <dt>루비 온 레이즈에 기여하기</dt>
              <dd><a href="contributing_to_ruby_on_rails.html">루비 온 레이즈에 기여하기</a></dd>
              <dd><a href="api_documentation_guidelines.html">API 문서 가이드라인</a></dd>
              <dd><a href="ruby_on_rails_guides_guidelines.html">루비 온 레일즈 가이드에 대한 가이드라인</a></dd>

              <dt>Release Notes</dt>
              <dd><a href="3_0_release_notes.html">Ruby on Rails 3.0 Release Notes</a></dd>
              <dd><a href="2_3_release_notes.html">Ruby on Rails 2.3 Release Notes</a></dd>
              <dd><a href="2_2_release_notes.html">Ruby on Rails 2.2 Release Notes</a></dd>
            </dl>
          </div>
        </li>
        <li><a href="contribute.html">기여하기</a></li>
        <li><a href="credits.html">수고하신 분들</a></li>
      </ul>
    </div>
  </div>
  <hr class="hide" />

  <div id="feature">
    <div class="wrapper">
      <h2>The Basics of Creating Rails Plugins</h2>
<p>A Rails plugin is either an extension or a modification of the core framework. Plugins provide:</p>
<ul>
	<li>a way for developers to share bleeding-edge ideas without hurting the stable code base</li>
	<li>a segmented architecture so that units of code can be fixed or updated on their own release schedule</li>
	<li>an outlet for the core developers so that they don’t have to include every cool new feature under the sun</li>
</ul>
<p>After reading this guide you should be familiar with:</p>
<ul>
	<li>Creating a plugin from scratch</li>
	<li>Writing and running tests for the plugin</li>
	<li>Storing models, views, controllers, helpers and even other plugins in your plugins</li>
	<li>Writing generators</li>
	<li>Writing custom Rake tasks in your plugin</li>
	<li>Generating RDoc documentation for your plugin</li>
	<li>Avoiding common pitfalls with &#8216;init.rb&#8217;</li>
</ul>
<p>This guide describes how to build a test-driven plugin that will:</p>
<ul>
	<li>Extend core ruby classes like Hash and String</li>
	<li>Add methods to ActiveRecord::Base in the tradition of the &#8216;acts_as&#8217; plugins</li>
	<li>Add a view helper that can be used in erb templates</li>
	<li>Add a new generator that will generate a migration</li>
	<li>Add a custom generator command</li>
	<li>A custom route method that can be used in routes.rb</li>
</ul>
<p>For the purpose of this guide pretend for a moment that you are an avid bird watcher. Your favorite bird is the Yaffle, and you want to create a plugin that allows other developers to share in the Yaffle goodness. First, you need to get setup for development.</p>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#setup">Setup</a><ul><li><a href="#create-the-basic-application">Create the Basic Application</a></li> <li><a href="#generate-the-plugin-skeleton">Generate the Plugin Skeleton</a></li> <li><a href="#organize-your-files">Organize Your Files</a></li></ul></li><li><a href="#tests">Tests</a><ul><li><a href="#test-setup">Test Setup</a></li> <li><a href="#run-the-plugin-tests">Run the Plugin Tests</a></li></ul></li><li><a href="#extending-core-classes">Extending Core Classes</a><ul><li><a href="#working-with-init-rb">Working with <tt>init.rb</tt></a></li></ul></li><li><a href="#add-an-acts_as-method-to-active-record">Add an &#8220;acts_as&#8221; Method to Active Record</a><ul><li><a href="#add-a-class-method">Add a Class Method</a></li> <li><a href="#add-an-instance-method">Add an Instance Method</a></li></ul></li><li><a href="#models">Models</a></li><li><a href="#controllers">Controllers</a></li><li><a href="#helpers">Helpers</a></li><li><a href="#routes">Routes</a></li><li><a href="#generators">Generators</a><ul><li><a href="#testing-generators">Testing Generators</a></li> <li><a href="#the-usage-file">The <tt>USAGE</tt> File</a></li></ul></li><li><a href="#add-a-custom-generator-command">Add a Custom Generator Command</a></li><li><a href="#generator-commands">Generator Commands</a></li><li><a href="#migrations">Migrations</a><ul><li><a href="#create-a-custom-rake-task">Create a Custom Rake Task</a></li> <li><a href="#call-migrations-directly">Call Migrations Directly</a></li> <li><a href="#generate-migrations">Generate Migrations</a></li></ul></li><li><a href="#rake-tasks">Rake Tasks</a></li><li><a href="#plugins-as-gems">Plugins as Gems</a></li><li><a href="#rdoc-documentation">RDoc Documentation</a></li><li><a href="#appendix">Appendix</a><ul><li><a href="#references">References</a></li> <li><a href="#contents-of-lib-yaffle-rb">Contents of <tt>lib/yaffle.rb</tt></a></li> <li><a href="#final-plugin-directory-structure">Final Plugin Directory Structure</a></li></ul></li><li><a href="#changelog">Changelog</a></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="setup">1 Setup</h3>
<h4 id="create-the-basic-application">1.1 Create the Basic Application</h4>
<p>The examples in this guide require that you have a working rails application. To create a simple one execute:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
gem install rails
rails new yaffle_guide
cd yaffle_guide
bundle install
rails generate scaffold bird name:string
rake db:migrate
rails server
</pre>
</div>
</notextile>

<p>Then navigate to http://localhost:3000/birds. Make sure you have a functioning rails application before continuing.</p>
<div class='note'><p>The aforementioned instructions will work for SQLite3. For more detailed instructions on how to create a Rails application for other databases see the <span class="caps">API</span> docs.</p></div>
<h4 id="generate-the-plugin-skeleton">1.2 Generate the Plugin Skeleton</h4>
<p>Rails ships with a plugin generator which creates a basic plugin skeleton. Pass the plugin name, either &#8216;CamelCased&#8217; or &#8216;under_scored&#8217;, as an argument. Pass <tt>--generator</tt> to add an example generator also.</p>
<p>This creates a plugin in <tt>vendor/plugins</tt> including an <tt>init.rb</tt> and <tt>README</tt> as well as standard <tt>lib</tt>, <tt>task</tt>, and <tt>test</tt> directories.</p>
<p>Examples:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails generate plugin yaffle
rails generate plugin yaffle --generator
</pre>
</div>
</notextile>

<p>To get more detailed help on the plugin generator, type <tt>rails generate plugin</tt>.</p>
<p>Later on this guide will describe how to work with generators, so go ahead and generate your plugin with the <tt>--generator</tt> option now:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails generate plugin yaffle --generator
</pre>
</div>
</notextile>

<p>You should see the following output:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
create  vendor/plugins/yaffle
create  vendor/plugins/yaffle/init.rb
create  vendor/plugins/yaffle/install.rb
create  vendor/plugins/yaffle/MIT-LICENSE
create  vendor/plugins/yaffle/Rakefile
create  vendor/plugins/yaffle/README
create  vendor/plugins/yaffle/uninstall.rb
create  vendor/plugins/yaffle/lib
create  vendor/plugins/yaffle/lib/yaffle.rb
invoke  generator
inside    vendor/plugins/yaffle
create      lib/generators
create      lib/generators/yaffle_generator.rb
create      lib/generators/USAGE
create      lib/generators/templates
invoke  test_unit
inside    vendor/plugins/yaffle
create      test
create      test/yaffle_test.rb
create      test/test_helper.rb
</pre>
</div>
</notextile>

<h4 id="organize-your-files">1.3 Organize Your Files</h4>
<p>To make it easy to organize your files and to make the plugin more compatible with GemPlugins, start out by altering your file system to look like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
|-- lib
|   |-- yaffle
|   `-- yaffle.rb
`-- init.rb
</pre>
</div>
</notextile>

<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/init.rb

require 'yaffle'
</pre>
</div>
</notextile>

<p>Now you can add any <tt>require</tt> statements to <tt>lib/yaffle.rb</tt> and keep <tt>init.rb</tt> clean.</p>
<h3 id="tests">2 Tests</h3>
<p>In this guide you will learn how to test your plugin against multiple different database adapters using Active Record. To setup your plugin to allow for easy testing you&#8217;ll need to add 3 files:</p>
<ul>
	<li>A <tt>database.yml</tt> file with all of your connection strings</li>
	<li>A <tt>schema.rb</tt> file with your table definitions</li>
	<li>A test helper method that sets up the database</li>
</ul>
<h4 id="test-setup">2.1 Test Setup</h4>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
# vendor/plugins/yaffle/test/database.yml

sqlite:
  adapter: sqlite
  database: vendor/plugins/yaffle/test/yaffle_plugin.sqlite.db

sqlite3:
  adapter: sqlite3
  database: vendor/plugins/yaffle/test/yaffle_plugin.sqlite3.db

postgresql:
  adapter: postgresql
  username: postgres
  password: postgres
  database: yaffle_plugin_test
  min_messages: ERROR

mysql:
  adapter: mysql2
  host: localhost
  username: root
  password: password
  database: yaffle_plugin_test
</pre>
</div>
</notextile>

<p>For this guide you&#8217;ll need 2 tables/models, Hickwalls and Wickwalls, so add the following:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/test/schema.rb

ActiveRecord::Schema.define(:version =&gt; 0) do
  create_table :hickwalls, :force =&gt; true do |t|
    t.string :name
    t.string :last_squawk
    t.datetime :last_squawked_at
  end
  create_table :wickwalls, :force =&gt; true do |t|
    t.string :name
    t.string :last_tweet
    t.datetime :last_tweeted_at
  end
  create_table :woodpeckers, :force =&gt; true do |t|
    t.string :name
  end
end
</pre>
</div>
</notextile>

<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/test/test_helper.rb

ENV['RAILS_ENV'] = 'test'
ENV['RAILS_ROOT'] ||= File.dirname(__FILE__) + '/../../../..'

require 'test/unit'
require File.expand_path(File.join(ENV['RAILS_ROOT'], 'config/environment.rb'))

def load_schema
  config = YAML::load(IO.read(File.dirname(__FILE__) + '/database.yml'))
  ActiveRecord::Base.logger = Logger.new(File.dirname(__FILE__) + &quot;/debug.log&quot;)

  db_adapter = ENV['DB']

  # no db passed, try one of these fine config-free DBs before bombing.
  db_adapter ||=
    begin
      require 'rubygems'
      require 'sqlite'
      'sqlite'
    rescue MissingSourceFile
      begin
        require 'sqlite3'
        'sqlite3'
      rescue MissingSourceFile
      end
    end

  if db_adapter.nil?
    raise &quot;No DB Adapter selected. Pass the DB= option to pick one, or install Sqlite or Sqlite3.&quot;
  end

  ActiveRecord::Base.establish_connection(config[db_adapter])
  load(File.dirname(__FILE__) + &quot;/schema.rb&quot;)
  require File.dirname(__FILE__) + '/../init'
end
</pre>
</div>
</notextile>

<p>Now whenever you write a test that requires the database, you can call &#8216;load_schema&#8217;.</p>
<h4 id="run-the-plugin-tests">2.2 Run the Plugin Tests</h4>
<p>Once you have these files in place, you can write your first test to ensure that your plugin-testing setup is correct. By default rails generates a file in <tt>vendor/plugins/yaffle/test/yaffle_test.rb</tt> with a sample test. Replace the contents of that file with:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/test/yaffle_test.rb

require 'test_helper'

class YaffleTest &lt; ActiveSupport::TestCase
  load_schema

  class Hickwall &lt; ActiveRecord::Base
  end

  class Wickwall &lt; ActiveRecord::Base
  end

  def test_schema_has_loaded_correctly
    assert_equal [], Hickwall.all
    assert_equal [], Wickwall.all
  end

end
</pre>
</div>
</notextile>

<p>To run this, go to the plugin directory and run <tt>rake</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
cd vendor/plugins/yaffle
rake
</pre>
</div>
</notextile>

<p>You should see output like:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
/opt/local/bin/ruby -Ilib:lib &quot;/opt/local/lib/ruby/gems/1.8/gems/rake-0.8.3/lib/rake/rake_test_loader.rb&quot; &quot;test/yaffle_test.rb&quot;
  create_table(:hickwalls, {:force=&gt;true})
   -&gt; 0.0220s
-- create_table(:wickwalls, {:force=&gt;true})
   -&gt; 0.0077s
-- create_table(:woodpeckers, {:force=&gt;true})
   -&gt; 0.0069s
-- initialize_schema_migrations_table()
   -&gt; 0.0007s
-- assume_migrated_upto_version(0, &quot;db/migrate&quot;)
   -&gt; 0.0007s
Loaded suite /opt/local/lib/ruby/gems/1.8/gems/rake-0.8.3/lib/rake/rake_test_loader
Started
.
Finished in 0.002236 seconds.

1 test, 2 assertion, 0 failures, 0 errors, 0 skips
</pre>
</div>
</notextile>

<p>By default the setup above runs your tests with SQLite or SQLite3. To run tests with one of the other connection strings specified in <tt>database.yml</tt>, pass the DB environment variable to rake:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rake DB=sqlite
rake DB=sqlite3
rake DB=mysql
rake DB=postgresql
</pre>
</div>
</notextile>

<p>Now you are ready to test-drive your plugin!</p>
<h3 id="extending-core-classes">3 Extending Core Classes</h3>
<p>This section will explain how to add a method to String that will be available anywhere in your Rails application.</p>
<p>In this example you will add a method to String named <tt>to_squawk</tt>. To begin, create a new test file with a few assertions:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/test/core_ext_test.rb

require File.dirname(__FILE__) + '/test_helper'

class CoreExtTest &lt; Test::Unit::TestCase
  def test_to_squawk_prepends_the_word_squawk
    assert_equal &quot;squawk! Hello World&quot;, &quot;Hello World&quot;.to_squawk
  end
end
</pre>
</div>
</notextile>

<p>Navigate to your plugin directory and run <tt>rake test</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
cd vendor/plugins/yaffle
rake test
</pre>
</div>
</notextile>

<p>The test above should fail with the message:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
1) Error:
test_to_squawk_prepends_the_word_squawk(CoreExtTest):
NoMethodError: undefined method `to_squawk' for &quot;Hello World&quot;:String
    ./test/core_ext_test.rb:5:in `test_to_squawk_prepends_the_word_squawk'
</pre>
</div>
</notextile>

<p>Great &#8211; now you are ready to start development.</p>
<p>Then in <tt>lib/yaffle.rb</tt> require <tt>lib/core_ext</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/lib/yaffle.rb

require &quot;yaffle/core_ext&quot;
</pre>
</div>
</notextile>

<p>Finally, create the <tt>core_ext.rb</tt> file and add the <tt>to_squawk</tt> method:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/lib/yaffle/core_ext.rb

String.class_eval do
  def to_squawk
    &quot;squawk! #{self}&quot;.strip
  end
end
</pre>
</div>
</notextile>

<p>To test that your method does what it says it does, run the unit tests with <tt>rake</tt> from your plugin directory. To see this in action, fire up a console and start squawking:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
$ rails console
&gt;&gt; &quot;Hello World&quot;.to_squawk
=&gt; &quot;squawk! Hello World&quot;
</pre>
</div>
</notextile>

<h4 id="working-with-init-rb">3.1 Working with <tt>init.rb</tt></h4>
<p>When Rails loads plugins it looks for a file named <tt>init.rb</tt>. However, when the plugin is initialized, <tt>init.rb</tt> is invoked via <tt>eval</tt> (not <tt>require</tt>) so it has slightly different behavior.</p>
<div class='note'><p>The plugins loader also looks for <tt>rails/init.rb</tt>, but that one is deprecated in favor of the top-level <tt>init.rb</tt> aforementioned.</p></div>
<p>Under certain circumstances if you reopen classes or modules in <tt>init.rb</tt> you may inadvertently create a new class, rather than reopening an existing class. A better alternative is to reopen the class in a different file, and require that file from <tt>init.rb</tt>, as shown above.</p>
<p>If you must reopen a class in <tt>init.rb</tt> you can use <tt>module_eval</tt> or <tt>class_eval</tt> to avoid any issues:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/init.rb

Hash.class_eval do
  def is_a_special_hash?
    true
  end
end
</pre>
</div>
</notextile>

<p>Another way is to explicitly define the top-level module space for all modules and classes, like <tt>::Hash</tt>:</p>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
# vendor/plugins/yaffle/init.rb

class ::Hash
  def is_a_special_hash?
    true
  end
end
</pre>
</div>
</notextile>

<h3 id="add-an-acts_as-method-to-active-record">4 Add an &#8220;acts_as&#8221; Method to Active Record</h3>
<p>A common pattern in plugins is to add a method called &#8216;acts_as_something&#8217; to models. In this case, you want to write a method called &#8216;acts_as_yaffle&#8217; that adds a &#8216;squawk&#8217; method to your models.</p>
<p>To begin, set up your files so that you have:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/acts_as_yaffle_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'

class ActsAsYaffleTest &lt; Test::Unit::TestCase
end
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'yaffle/acts_as_yaffle'
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Yaffle
  # your code will go here
end
</pre>
</div>
</notextile>

<p>Note that after requiring &#8216;acts_as_yaffle&#8217; you also have to include it into ActiveRecord::Base so that your plugin methods will be available to the rails models.</p>
<p>One of the most common plugin patterns for &#8216;acts_as_yaffle&#8217; plugins is to structure your file like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    # any method placed here will apply to classes, like Hickwall
    def acts_as_something
      send :include, InstanceMethods
    end
  end

  module InstanceMethods
    # any method placed here will apply to instaces, like @hickwall
  end
end
</pre>
</div>
</notextile>

<p>With structure you can easily separate the methods that will be used for the class (like <tt>Hickwall.some_method</tt>) and the instance (like <tt>@hickwell.some_method</tt>).</p>
<h4 id="add-a-class-method">4.1 Add a Class Method</h4>
<p>This plugin will expect that you&#8217;ve added a method to your model named &#8216;last_squawk&#8217;. However, the plugin users might have already defined a method on their model named &#8216;last_squawk&#8217; that they use for something else. This plugin will allow the name to be changed by adding a class method called &#8216;yaffle_text_field&#8217;.</p>
<p>To start out, write a failing test that shows the behavior you&#8217;d like:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/acts_as_yaffle_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'

class Hickwall &lt; ActiveRecord::Base
  acts_as_yaffle
end

class Wickwall &lt; ActiveRecord::Base
  acts_as_yaffle :yaffle_text_field =&gt; :last_tweet
end

class ActsAsYaffleTest &lt; Test::Unit::TestCase
  load_schema

  def test_a_hickwalls_yaffle_text_field_should_be_last_squawk
    assert_equal &quot;last_squawk&quot;, Hickwall.yaffle_text_field
  end

  def test_a_wickwalls_yaffle_text_field_should_be_last_tweet
    assert_equal &quot;last_tweet&quot;, Wickwall.yaffle_text_field
  end
end
</pre>
</div>
</notextile>

<p>To make these tests pass, you could modify your <tt>acts_as_yaffle</tt> file like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    def acts_as_yaffle(options = {})
      cattr_accessor :yaffle_text_field
      self.yaffle_text_field = (options[:yaffle_text_field] || :last_squawk).to_s
    end
  end
end

ActiveRecord::Base.send :include, Yaffle
</pre>
</div>
</notextile>

<h4 id="add-an-instance-method">4.2 Add an Instance Method</h4>
<p>This plugin will add a method named &#8216;squawk&#8217; to any Active Record objects that call &#8216;acts_as_yaffle&#8217;. The &#8216;squawk&#8217; method will simply set the value of one of the fields in the database.</p>
<p>To start out, write a failing test that shows the behavior you&#8217;d like:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/acts_as_yaffle_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'

class Hickwall &lt; ActiveRecord::Base
  acts_as_yaffle
end

class Wickwall &lt; ActiveRecord::Base
  acts_as_yaffle :yaffle_text_field =&gt; :last_tweet
end

class ActsAsYaffleTest &lt; Test::Unit::TestCase
  load_schema

  def test_a_hickwalls_yaffle_text_field_should_be_last_squawk
    assert_equal &quot;last_squawk&quot;, Hickwall.yaffle_text_field
  end

  def test_a_wickwalls_yaffle_text_field_should_be_last_tweet
    assert_equal &quot;last_tweet&quot;, Wickwall.yaffle_text_field
  end

  def test_hickwalls_squawk_should_populate_last_squawk
    hickwall = Hickwall.new
    hickwall.squawk(&quot;Hello World&quot;)
    assert_equal &quot;squawk! Hello World&quot;, hickwall.last_squawk
  end

  def test_wickwalls_squawk_should_populate_last_tweeted_at
    wickwall = Wickwall.new
    wickwall.squawk(&quot;Hello World&quot;)
    assert_equal &quot;squawk! Hello World&quot;, wickwall.last_tweet
  end
end
</pre>
</div>
</notextile>

<p>Run this test to make sure the last two tests fail, then update &#8216;acts_as_yaffle.rb&#8217; to look like this:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/acts_as_yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Yaffle
  def self.included(base)
    base.send :extend, ClassMethods
  end

  module ClassMethods
    def acts_as_yaffle(options = {})
      cattr_accessor :yaffle_text_field
      self.yaffle_text_field = (options[:yaffle_text_field] || :last_squawk).to_s
      send :include, InstanceMethods
    end
  end

  module InstanceMethods
    def squawk(string)
      write_attribute(self.class.yaffle_text_field, string.to_squawk)
    end
  end
end

ActiveRecord::Base.send :include, Yaffle
</pre>
</div>
</notextile>

<div class='note'><p>The use of <tt>write_attribute</tt> to write to the field in model is just one example of how a plugin can interact with the model, and will not always be the right method to use. For example, you could also use <tt>send("#{self.class.yaffle_text_field}=", string.to_squawk)</tt>.</p></div>
<h3 id="models">5 Models</h3>
<p>This section describes how to add a model named &#8216;Woodpecker&#8217; to your plugin that will behave the same as a model in your main app. When storing models, controllers, views and helpers in your plugin, it&#8217;s customary to keep them in directories that match the rails directories. For this example, create a file structure like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
vendor/plugins/yaffle/
|-- lib
|   |-- app
|   |   |-- controllers
|   |   |-- helpers
|   |   |-- models
|   |   |   `-- woodpecker.rb
|   |   `-- views
|   |-- yaffle
|   |   |-- acts_as_yaffle.rb
|   |   |-- commands.rb
|   |   `-- core_ext.rb
|   `-- yaffle.rb
</pre>
</div>
</notextile>

<p>As always, start with a test:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/woodpecker_test.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'

class WoodpeckerTest &lt; Test::Unit::TestCase
  load_schema

  def test_woodpecker
    assert_kind_of Woodpecker, Woodpecker.new
  end
end
</pre>
</div>
</notextile>

<p>This is just a simple test to make sure the class is being loaded correctly. After watching it fail with <tt>rake</tt>, you can make it pass like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
%w{ models }.each do |dir|
  path = File.join(File.dirname(__FILE__), 'app', dir)
  $LOAD_PATH &lt;&lt; path
  ActiveSupport::Dependencies.autoload_paths &lt;&lt; path
  ActiveSupport::Dependencies.autoload_once_paths.delete(path)
end
</pre>
</div>
</notextile>

<p>Adding directories to the load path makes them appear just like files in the main app directory &#8211; except that they are only loaded once, so you have to restart the web server to see the changes in the browser. Removing directories from the &#8216;load_once_paths&#8217; allow those changes to picked up as soon as you save the file &#8211; without having to restart the web server. This is particularly useful as you develop the plugin.</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/app/models/woodpecker.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class Woodpecker &lt; ActiveRecord::Base
end
</pre>
</div>
</notextile>

<p>Finally, add the following to your plugin&#8217;s &#8216;schema.rb&#8217;:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/schema.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
create_table :woodpeckers, :force =&gt; true do |t|
  t.string :name
end
</pre>
</div>
</notextile>

<p>Now your test should be passing, and you should be able to use the Woodpecker model from within your rails application, and any changes made to it are reflected immediately when running in development mode.</p>
<h3 id="controllers">6 Controllers</h3>
<p>This section describes how to add a controller named &#8216;woodpeckers&#8217; to your plugin that will behave the same as a controller in your main app. This is very similar to adding a model.</p>
<p>You can test your plugin&#8217;s controller as you would test any other controller:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/woodpeckers_controller_test.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'
require 'woodpeckers_controller'
require 'action_controller/test_process'

class WoodpeckersController; def rescue_action(e) raise e end; end

class WoodpeckersControllerTest &lt; Test::Unit::TestCase
  def setup
    @controller = WoodpeckersController.new
    @request = ActionController::TestRequest.new
    @response = ActionController::TestResponse.new

    ActionController::Routing::Routes.draw do |map|
      map.resources :woodpeckers
    end
  end

  def test_index
    get :index
    assert_response :success
  end
end
</pre>
</div>
</notextile>

<p>This is just a simple test to make sure the controller is being loaded correctly. After watching it fail with <tt>rake</tt>, you can make it pass like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
%w{ models controllers }.each do |dir|
  path = File.join(File.dirname(__FILE__), 'app', dir)
  $LOAD_PATH &lt;&lt; path
  ActiveSupport::Dependencies.autoload_paths &lt;&lt; path
  ActiveSupport::Dependencies.autoload_once_paths.delete(path)
end
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/app/controllers/woodpeckers_controller.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class WoodpeckersController &lt; ActionController::Base

  def index
    render :text =&gt; &quot;Squawk!&quot;
  end

end
</pre>
</div>
</notextile>

<p>Now your test should be passing, and you should be able to use the Woodpeckers controller in your app. If you add a route for the woodpeckers controller you can start up your server and go to http://localhost:3000/woodpeckers to see your controller in action.</p>
<h3 id="helpers">7 Helpers</h3>
<p>This section describes how to add a helper named &#8216;WoodpeckersHelper&#8217; to your plugin that will behave the same as a helper in your main app. This is very similar to adding a model and a controller.</p>
<p>You can test your plugin&#8217;s helper as you would test any other helper:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/woodpeckers_helper_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'
include WoodpeckersHelper

class WoodpeckersHelperTest &lt; Test::Unit::TestCase
  def test_tweet
    assert_equal &quot;Tweet! Hello&quot;, tweet(&quot;Hello&quot;)
  end
end
</pre>
</div>
</notextile>

<p>This is just a simple test to make sure the helper is being loaded correctly. After watching it fail with <tt>rake</tt>, you can make it pass like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
%w{ models controllers helpers }.each do |dir|
  path = File.join(File.dirname(__FILE__), 'app', dir)
  $LOAD_PATH &lt;&lt; path
  ActiveSupport::Dependencies.autoload_paths &lt;&lt; path
  ActiveSupport::Dependencies.autoload_once_paths.delete(path)
end
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/app/helpers/woodpeckers_helper.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module WoodpeckersHelper

  def tweet(text)
    &quot;Tweet! #{text}&quot;
  end

end
</pre>
</div>
</notextile>

<p>Now your test should be passing, and you should be able to use the Woodpeckers helper in your app.</p>
<h3 id="routes">8 Routes</h3>
<p>You can add your own custom routes from a plugin. This section will describe how to add a custom method that can be called with &#8216;map.yaffles&#8217;.</p>
<p>Testing routes from plugins is slightly different from testing routes in a standard Rails application. To begin, add a test like this:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/routing_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;#{File.dirname(__FILE__)}/test_helper&quot;

class RoutingTest &lt; Test::Unit::TestCase

  def setup
    ActionController::Routing::Routes.draw do |map|
      map.yaffles
    end
  end

  def test_yaffles_route
    assert_recognition :get, &quot;/yaffles&quot;, :controller =&gt; &quot;yaffles_controller&quot;, :action =&gt; &quot;index&quot;
  end

  private

    def assert_recognition(method, path, options)
      result = ActionController::Routing::Routes.recognize_path(path, :method =&gt; method)
      assert_equal options, result
    end
end
</pre>
</div>
</notextile>

<p>Once you see the tests fail by running &#8216;rake&#8217;, you can make them pass with:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;yaffle/routing&quot;
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/routing.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
module Yaffle #:nodoc:
  module Routing #:nodoc:
    module MapperExtensions
      def yaffles
        @set.add_route(&quot;/yaffles&quot;, {:controller =&gt; &quot;yaffles_controller&quot;, :action =&gt; &quot;index&quot;})
      end
    end
  end
end

ActionController::Routing::RouteSet::Mapper.send :include, Yaffle::Routing::MapperExtensions
</pre>
</div>
</notextile>

<ul>
	<li><strong>config/routes.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
ActionController::Routing::Routes.draw do |map|
  map.yaffles
end
</pre>
</div>
</notextile>

<p>You can also see if your routes work by running <tt>rake routes</tt> from your app directory.</p>
<h3 id="generators">9 Generators</h3>
<p>Many plugins ship with generators. When you created the plugin above, you specified the <tt>--generator</tt> option, so you already have the generator stubs in &#8216;vendor/plugins/yaffle/generators/yaffle&#8217;.</p>
<p>Building generators is a complex topic unto itself and this section will cover one small aspect of generators: generating a simple text file.</p>
<h4 id="testing-generators">9.1 Testing Generators</h4>
<p>Many rails plugin authors do not test their generators, however testing generators is quite simple. A typical generator test does the following:</p>
<ul>
	<li>Creates a new fake rails root directory that will serve as destination</li>
	<li>Runs the generator</li>
	<li>Asserts that the correct files were generated</li>
	<li>Removes the fake rails root</li>
</ul>
<p>This section will describe how to create a simple generator that adds a file. For the generator in this section, the test could look something like this:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/definition_generator_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'
require 'rails_generator'
require 'rails_generator/scripts/generate'

class DefinitionGeneratorTest &lt; Test::Unit::TestCase

  def setup
    FileUtils.mkdir_p(fake_rails_root)
    @original_files = file_list
  end

  def teardown
    FileUtils.rm_r(fake_rails_root)
  end

  def test_generates_correct_file_name
    Rails::Generator::Scripts::Generate.new.run([&quot;yaffle_definition&quot;], :destination =&gt; fake_rails_root)
    new_file = (file_list - @original_files).first
    assert_equal &quot;definition.txt&quot;, File.basename(new_file)
  end

  private

    def fake_rails_root
      File.join(File.dirname(__FILE__), 'rails_root')
    end

    def file_list
      Dir.glob(File.join(fake_rails_root, &quot;*&quot;))
    end

end
</pre>
</div>
</notextile>

<p>You can run &#8216;rake&#8217; from the plugin directory to see this fail. Unless you are doing more advanced generator commands it typically suffices to just test the Generate script, and trust that rails will handle the Destroy and Update commands for you.</p>
<p>To make it pass, create the generator:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/generators/yaffle_definition/yaffle_definition_generator.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class YaffleDefinitionGenerator &lt; Rails::Generator::Base
  def manifest
    record do |m|
      m.file &quot;definition.txt&quot;, &quot;definition.txt&quot;
    end
  end
end
</pre>
</div>
</notextile>

<h4 id="the-usage-file">9.2 The <tt>USAGE</tt> File</h4>
<p>If you plan to distribute your plugin, developers will expect at least a minimum of documentation. You can add simple documentation to the generator by updating the <span class="caps">USAGE</span> file.</p>
<p>Rails ships with several built-in generators. You can see all of the generators available to you by typing the following at the command line:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails generate
</pre>
</div>
</notextile>

<p>You should see something like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Installed Generators
  Plugins (vendor/plugins): yaffle_definition
  Builtin: controller, integration_test, mailer, migration, model, observer, plugin, resource, scaffold, session_migration
</pre>
</div>
</notextile>

<p>When you run <tt>rails generate yaffle_definition -h</tt> you should see the contents of your &#8216;vendor/plugins/yaffle/generators/yaffle_definition/<span class="caps">USAGE</span>&#8217;.</p>
<p>For this plugin, update the <span class="caps">USAGE</span> file could look like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Description:
    Adds a file with the definition of a Yaffle to the app's main directory
</pre>
</div>
</notextile>

<h3 id="add-a-custom-generator-command">10 Add a Custom Generator Command</h3>
<p>You may have noticed above that you can used one of the built-in rails migration commands <tt>migration_template</tt>. If your plugin needs to add and remove lines of text from existing files you will need to write your own generator methods.</p>
<p>This section describes how you you can create your own commands to add and remove a line of text from &#8216;routes.rb&#8217;. This example creates a very simple method that adds or removes a text file.</p>
<p>To start, add the following test method:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/generator_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
def test_generates_definition
  Rails::Generator::Scripts::Generate.new.run([&quot;yaffle&quot;, &quot;bird&quot;], :destination =&gt; fake_rails_root)
  definition = File.read(File.join(fake_rails_root, &quot;definition.txt&quot;))
  assert_match /Yaffle\:/, definition
end
</pre>
</div>
</notextile>

<p>Run <tt>rake</tt> to watch the test fail, then make the test pass add the following:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/generators/yaffle/templates/definition.txt</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
Yaffle: A bird
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;yaffle/commands&quot;
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/commands.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails_generator'
require 'rails_generator/commands'

module Yaffle #:nodoc:
  module Generator #:nodoc:
    module Commands #:nodoc:
      module Create
        def yaffle_definition
          file(&quot;definition.txt&quot;, &quot;definition.txt&quot;)
        end
      end

      module Destroy
        def yaffle_definition
          file(&quot;definition.txt&quot;, &quot;definition.txt&quot;)
        end
      end

      module List
        def yaffle_definition
          file(&quot;definition.txt&quot;, &quot;definition.txt&quot;)
        end
      end

      module Update
        def yaffle_definition
          file(&quot;definition.txt&quot;, &quot;definition.txt&quot;)
        end
      end
    end
  end
end

Rails::Generator::Commands::Create.send   :include,  Yaffle::Generator::Commands::Create
Rails::Generator::Commands::Destroy.send  :include,  Yaffle::Generator::Commands::Destroy
Rails::Generator::Commands::List.send     :include,  Yaffle::Generator::Commands::List
Rails::Generator::Commands::Update.send   :include,  Yaffle::Generator::Commands::Update
</pre>
</div>
</notextile>

<p>Finally, call your new method in the manifest:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/generators/yaffle/yaffle_generator.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class YaffleGenerator &lt; Rails::Generator::NamedBase
  def manifest
    m.yaffle_definition
  end
end
</pre>
</div>
</notextile>

<h3 id="generator-commands">11 Generator Commands</h3>
<p>You may have noticed above that you can used one of the built-in rails migration commands <tt>migration_template</tt>. If your plugin needs to add and remove lines of text from existing files you will need to write your own generator methods.</p>
<p>This section describes how you you can create your own commands to add and remove a line of text from &#8216;config/routes.rb&#8217;.</p>
<p>To start, add the following test method:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/route_generator_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'
require 'rails_generator'
require 'rails_generator/scripts/generate'
require 'rails_generator/scripts/destroy'

class RouteGeneratorTest &lt; Test::Unit::TestCase

  def setup
    FileUtils.mkdir_p(File.join(fake_rails_root, &quot;config&quot;))
  end

  def teardown
    FileUtils.rm_r(fake_rails_root)
  end

  def test_generates_route
    content = &lt;&lt;-END
      ActionController::Routing::Routes.draw do |map|
        map.connect ':controller/:action/:id'
        map.connect ':controller/:action/:id.:format'
      end
    END
    File.open(routes_path, 'wb') {|f| f.write(content) }

    Rails::Generator::Scripts::Generate.new.run([&quot;yaffle_route&quot;], :destination =&gt; fake_rails_root)
    assert_match /map\.yaffles/, File.read(routes_path)
  end

  def test_destroys_route
    content = &lt;&lt;-END
      ActionController::Routing::Routes.draw do |map|
        map.yaffles
        map.connect ':controller/:action/:id'
        map.connect ':controller/:action/:id.:format'
      end
    END
    File.open(routes_path, 'wb') {|f| f.write(content) }

    Rails::Generator::Scripts::Destroy.new.run([&quot;yaffle_route&quot;], :destination =&gt; fake_rails_root)
    assert_no_match /map\.yaffles/, File.read(routes_path)
  end

  private

    def fake_rails_root
      File.join(File.dirname(__FILE__), &quot;rails_root&quot;)
    end

    def routes_path
      File.join(fake_rails_root, &quot;config&quot;, &quot;routes.rb&quot;)
    end

end
</pre>
</div>
</notextile>

<p>Run <tt>rake</tt> to watch the test fail, then make the test pass add the following:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;yaffle/commands&quot;
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle/commands.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require 'rails_generator'
require 'rails_generator/commands'

module Yaffle #:nodoc:
  module Generator #:nodoc:
    module Commands #:nodoc:
      module Create
        def yaffle_route
          logger.route &quot;map.yaffle&quot;
          look_for = 'ActionController::Routing::Routes.draw do |map|'
          unless options[:pretend]
            gsub_file('config/routes.rb', /(#{Regexp.escape(look_for)})/mi){|match| &quot;#{match}\n  map.yaffles\n&quot;}
          end
        end
      end

      module Destroy
        def yaffle_route
          logger.route &quot;map.yaffle&quot;
          gsub_file 'config/routes.rb', /\n.+?map\.yaffles/mi, ''
        end
      end

      module List
        def yaffle_route
        end
      end

      module Update
        def yaffle_route
        end
      end
    end
  end
end

Rails::Generator::Commands::Create.send   :include,  Yaffle::Generator::Commands::Create
Rails::Generator::Commands::Destroy.send  :include,  Yaffle::Generator::Commands::Destroy
Rails::Generator::Commands::List.send     :include,  Yaffle::Generator::Commands::List
Rails::Generator::Commands::Update.send   :include,  Yaffle::Generator::Commands::Update
</pre>
</div>
</notextile>

<ul>
	<li><strong>vendor/plugins/yaffle/generators/yaffle_route/yaffle_route_generator.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class YaffleRouteGenerator &lt; Rails::Generator::Base
  def manifest
    record do |m|
      m.yaffle_route
    end
  end
end
</pre>
</div>
</notextile>

<p>To see this work, type:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails generate yaffle_route
rails destroy yaffle_route
</pre>
</div>
</notextile>

<div class='note'><p>If you haven&#8217;t set up the custom route from above, &#8216;rails destroy&#8217; will fail and you&#8217;ll have to remove it manually.</p></div>
<h3 id="migrations">12 Migrations</h3>
<p>If your plugin requires changes to the app&#8217;s database you will likely want to somehow add migrations. Rails does not include any built-in support for calling migrations from plugins, but you can still make it easy for developers to call migrations from plugins.</p>
<p>If you have a very simple needs, like creating a table that will always have the same name and columns, then you can use a more simple solution, like creating a custom rake task or method. If your migration needs user input to supply table names or other options, you probably want to opt for generating a migration.</p>
<p>Let&#8217;s say you have the following migration in your plugin:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/db/migrate/20081116181115_create_birdhouses.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateBirdhouses &lt; ActiveRecord::Migration
  def self.up
    create_table :birdhouses, :force =&gt; true do |t|
      t.string :name
      t.timestamps
    end
  end

  def self.down
    drop_table :birdhouses
  end
end
</pre>
</div>
</notextile>

<p>Here are a few possibilities for how to allow developers to use your plugin migrations:</p>
<h4 id="create-a-custom-rake-task">12.1 Create a Custom Rake Task</h4>
<ul>
	<li><strong>vendor/plugins/yaffle/tasks/yaffle_tasks.rake:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
namespace :db do
  namespace :migrate do
    description = &quot;Migrate the database through scripts in vendor/plugins/yaffle/lib/db/migrate&quot;
    description &lt;&lt; &quot;and update db/schema.rb by invoking db:schema:dump.&quot;
    description &lt;&lt; &quot;Target specific version with VERSION=x. Turn off output with VERBOSE=false.&quot;

    desc description
    task :yaffle =&gt; :environment do
      ActiveRecord::Migration.verbose = ENV[&quot;VERBOSE&quot;] ? ENV[&quot;VERBOSE&quot;] == &quot;true&quot; : true
      ActiveRecord::Migrator.migrate(&quot;vendor/plugins/yaffle/lib/db/migrate/&quot;, ENV[&quot;VERSION&quot;] ? ENV[&quot;VERSION&quot;].to_i : nil)
      Rake::Task[&quot;db:schema:dump&quot;].invoke if ActiveRecord::Base.schema_format == :ruby
    end
  end
end
</pre>
</div>
</notextile>

<h4 id="call-migrations-directly">12.2 Call Migrations Directly</h4>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
Dir.glob(File.join(File.dirname(__FILE__), &quot;db&quot;, &quot;migrate&quot;, &quot;*&quot;)).each do |file|
  require file
end
</pre>
</div>
</notextile>

<ul>
	<li><strong>db/migrate/20081116181115_create_birdhouses.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class CreateBirdhouses &lt; ActiveRecord::Migration
  def self.up
    Yaffle::CreateBirdhouses.up
  end

  def self.down
    Yaffle::CreateBirdhouses.down
  end
end
</pre>
</div>
</notextile>

<div class='note'><p>several plugin frameworks such as Desert and Engines provide more advanced plugin functionality.</p></div>
<h4 id="generate-migrations">12.3 Generate Migrations</h4>
<p>Generating migrations has several advantages over other methods. Namely, you can allow other developers to more easily customize the migration. The flow looks like this:</p>
<ul>
	<li>call your rails generate script and pass in whatever options they need</li>
	<li>examine the generated migration, adding/removing columns or other options as necessary</li>
</ul>
<p>This example will demonstrate how to use one of the built-in generator methods named &#8216;migration_template&#8217; to create a migration file. Extending the rails migration generator requires a somewhat intimate knowledge of the migration generator internals, so it&#8217;s best to write a test first:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/test/yaffle_migration_generator_test.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require File.dirname(__FILE__) + '/test_helper'
require 'rails_generator'
require 'rails_generator/scripts/generate'

class MigrationGeneratorTest &lt; Test::Unit::TestCase

  def setup
    FileUtils.mkdir_p(fake_rails_root)
    @original_files = file_list
  end

  def teardown
    ActiveRecord::Base.pluralize_table_names = true
    FileUtils.rm_r(fake_rails_root)
  end

  def test_generates_correct_file_name
    Rails::Generator::Scripts::Generate.new.run([&quot;yaffle_migration&quot;, &quot;some_name_nobody_is_likely_to_ever_use_in_a_real_migration&quot;],
      :destination =&gt; fake_rails_root)
    new_file = (file_list - @original_files).first
    assert_match /add_yaffle_fields_to_some_name_nobody_is_likely_to_ever_use_in_a_real_migrations/, new_file
    assert_match /add_column :some_name_nobody_is_likely_to_ever_use_in_a_real_migrations do |t|/, File.read(new_file)
  end

  def test_pluralizes_properly
    ActiveRecord::Base.pluralize_table_names = false
    Rails::Generator::Scripts::Generate.new.run([&quot;yaffle_migration&quot;, &quot;some_name_nobody_is_likely_to_ever_use_in_a_real_migration&quot;],
      :destination =&gt; fake_rails_root)
    new_file = (file_list - @original_files).first
    assert_match /add_yaffle_fields_to_some_name_nobody_is_likely_to_ever_use_in_a_real_migration/, new_file
    assert_match /add_column :some_name_nobody_is_likely_to_ever_use_in_a_real_migration do |t|/, File.read(new_file)
  end

  private
    def fake_rails_root
      File.join(File.dirname(__FILE__), 'rails_root')
    end

    def file_list
      Dir.glob(File.join(fake_rails_root, &quot;db&quot;, &quot;migrate&quot;, &quot;*&quot;))
    end

end
</pre>
</div>
</notextile>

<div class='note'><p>The migration generator checks to see if a migration already exists, and it&#8217;s hard-coded to check the <tt>db/migrate</tt> directory. As a result, if your test tries to generate a migration that already exists in the app, it will fail. The easy workaround is to make sure that the name you generate in your test is very unlikely to actually appear in the app.</p></div>
<p>After running the test with &#8216;rake&#8217; you can make it pass with:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/generators/yaffle_migration/yaffle_migration_generator.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class YaffleMigrationGenerator &lt; Rails::Generator::NamedBase
  def manifest
    record do |m|
      m.migration_template 'migration:migration.rb', &quot;db/migrate&quot;, {:assigns =&gt; yaffle_local_assigns,
        :migration_file_name =&gt; &quot;add_yaffle_fields_to_#{custom_file_name}&quot;
      }
    end
  end

  private
    def custom_file_name
      custom_name = class_name.underscore.downcase
      custom_name = custom_name.pluralize if ActiveRecord::Base.pluralize_table_names
      custom_name
    end

    def yaffle_local_assigns
      {}.tap do |assigns|
        assigns[:migration_action] = &quot;add&quot;
        assigns[:class_name] = &quot;add_yaffle_fields_to_#{custom_file_name}&quot;
        assigns[:table_name] = custom_file_name
        assigns[:attributes] = [Rails::Generator::GeneratedAttribute.new(&quot;last_squawk&quot;, &quot;string&quot;)]
      end
    end
end
</pre>
</div>
</notextile>

<p>The generator creates a new file in &#8216;db/migrate&#8217; with a timestamp and an &#8216;add_column&#8217; statement. It reuses the built-in Rails <tt>migration_template</tt> method, and reuses the built-in rails migration template.</p>
<p>It&#8217;s courteous to check to see if table names are being pluralized whenever you create a generator that needs to be aware of table names. This way people using your generator won&#8217;t have to manually change the generated files if they&#8217;ve turned pluralization off.</p>
<p>To run the generator, type the following at the command line:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rails generate yaffle_migration bird
</pre>
</div>
</notextile>

<p>and you will see a new file:</p>
<ul>
	<li><strong>db/migrate/20080529225649_add_yaffle_fields_to_birds.rb</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
class AddYaffleFieldsToBirds &lt; ActiveRecord::Migration
  def self.up
    add_column :birds, :last_squawk, :string
  end

  def self.down
    remove_column :birds, :last_squawk
  end
end
</pre>
</div>
</notextile>

<h3 id="rake-tasks">13 Rake Tasks</h3>
<p>When you created the plugin with the built-in rails generator, it generated a rake file for you in &#8216;vendor/plugins/yaffle/tasks/yaffle_tasks.rake&#8217;. Any rake task you add here will be available to the app.</p>
<p>Many plugin authors put all of their rake tasks into a common namespace that is the same as the plugin, like so:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/tasks/yaffle_tasks.rake</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
namespace :yaffle do
  desc &quot;Prints out the word 'Yaffle'&quot;
  task :squawk =&gt; :environment do
    puts &quot;squawk!&quot;
  end
end
</pre>
</div>
</notextile>

<p>When you run <tt>rake -T</tt> from your plugin you will see:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
yaffle:squawk             # Prints out the word 'Yaffle'
</pre>
</div>
</notextile>

<p>You can add as many files as you want in the tasks directory, and if they end in .rake Rails will pick them up.</p>
<p>Note that tasks from <tt>vendor/plugins/yaffle/Rakefile</tt> are not available to the main app.</p>
<h3 id="plugins-as-gems">14 Plugins as Gems</h3>
<p>Turning your rails plugin into a gem is a simple and straightforward task. This section will cover how to turn your plugin into a gem. It will not cover how to distribute that gem.</p>
<p>Rails 3 ignores both <tt>init.rb</tt> and <tt>rails/init.rb</tt> file of a gem. Also, the name of the plugin now is relevant since <tt>config.gem</tt> tries to load it. Either name the main file after your gem, or document that users should use the <tt>:lib</tt> option.</p>
<p>It&#8217;s common practice to put any developer-centric rake tasks (such as tests, rdoc and gem package tasks) in <tt>Rakefile</tt>. A rake task that packages the gem might look like this:</p>
<ul>
	<li><strong>vendor/plugins/yaffle/Rakefile:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
PKG_FILES = FileList[
  '[a-zA-Z]*',
  'generators/**/*',
  'lib/**/*',
  'rails/**/*',
  'tasks/**/*',
  'test/**/*'
]

spec = Gem::Specification.new do |s|
  s.name = &quot;yaffle&quot;
  s.version = &quot;0.0.1&quot;
  s.author = &quot;Gleeful Yaffler&quot;
  s.email = &quot;yaffle@example.com&quot;
  s.homepage = &quot;http://yafflers.example.com/&quot;
  s.platform = Gem::Platform::RUBY
  s.summary = &quot;Sharing Yaffle Goodness&quot;
  s.files = PKG_FILES.to_a
  s.require_path = &quot;lib&quot;
  s.has_rdoc = false
  s.extra_rdoc_files = [&quot;README&quot;]
end

desc 'Turn this plugin into a gem.'
Rake::GemPackageTask.new(spec) do |pkg|
  pkg.gem_spec = spec
end
</pre>
</div>
</notextile>

<p>To build and install the gem locally, run the following commands:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
cd vendor/plugins/yaffle
rake gem
sudo gem install pkg/yaffle-0.0.1.gem
</pre>
</div>
</notextile>

<p>To test this, create a new rails application, add <tt>config.gem "yaffle"</tt> to <tt>config/environment.rb</tt> and all of your plugin&#8217;s functionality will be available to you.</p>
<h3 id="rdoc-documentation">15 RDoc Documentation</h3>
<p>Once your plugin is stable and you are ready to deploy do everyone else a favor and document it!  Luckily, writing documentation for your plugin is easy.</p>
<p>The first step is to update the <span class="caps">README</span> file with detailed information about how to use your plugin. A few key things to include are:</p>
<ul>
	<li>Your name</li>
	<li>How to install</li>
	<li>How to add the functionality to the app (several examples of common use cases)</li>
	<li>Warning, gotchas or tips that might help save users time</li>
</ul>
<p>Once your <span class="caps">README</span> is solid, go through and add rdoc comments to all of the methods that developers will use. It&#8217;s also customary to add &#8216;#:nodoc:&#8217; comments to those parts of the code that are not part of the public api.</p>
<p>Once your comments are good to go, navigate to your plugin directory and run:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
rake rdoc
</pre>
</div>
</notextile>

<h3 id="appendix">16 Appendix</h3>
<p>If you prefer to use RSpec instead of Test::Unit, you may be interested in the <a href="http://github.com/patmaddox/rspec-plugin-generator">RSpec Plugin Generator</a>.</p>
<h4 id="references">16.1 References</h4>
<ul>
	<li><a href="http://nubyonrails.com/articles/the-complete-guide-to-rails-plugins-part-i">Complete Guide to Rails Plugins &#8211; Part 1</a></li>
	<li><a href="http://nubyonrails.com/articles/the-complete-guide-to-rails-plugins-part-ii">Complete Guide to Rails Plugins &#8211; Part 2</a></li>
	<li><a href="http://github.com/technoweenie/attachment_fu/tree/master">Attachment_fu Plugin</a></li>
	<li><a href="http://daddy.platte.name/2007/05/rails-plugins-keep-initrb-thin.html">Keeping init.rb thin</a></li>
	<li><a href="http://www.mbleigh.com/2008/06/11/gemplugins-a-brief-introduction-to-the-future-of-rails-plugins">GemPlugins</a></li>
	<li><a href="http://weblog.jamisbuck.org/2006/10/26/monkey-patching-rails-extending-routes-2">Extending Routes</a></li>
</ul>
<h4 id="contents-of-lib-yaffle-rb">16.2 Contents of <tt>lib/yaffle.rb</tt></h4>
<ul>
	<li><strong>vendor/plugins/yaffle/lib/yaffle.rb:</strong></li>
</ul>
<notextile>
<div class="code_container">
<pre class="brush: ruby; gutter: false; toolbar: false">
require &quot;yaffle/core_ext&quot;
require &quot;yaffle/acts_as_yaffle&quot;
require &quot;yaffle/commands&quot;
require &quot;yaffle/routing&quot;

%w{ models controllers helpers }.each do |dir|
  path = File.join(File.dirname(__FILE__), 'app', dir)
  $LOAD_PATH &lt;&lt; path
  ActiveSupport::Dependencies.autoload_paths &lt;&lt; path
  ActiveSupport::Dependencies.autoload_once_paths.delete(path)
end

# optionally:
# Dir.glob(File.join(File.dirname(__FILE__), &quot;db&quot;, &quot;migrate&quot;, &quot;*&quot;)).each do |file|
#   require file
# end
</pre>
</div>
</notextile>

<h4 id="final-plugin-directory-structure">16.3 Final Plugin Directory Structure</h4>
<p>The final plugin should have a directory structure that looks something like this:</p>
<notextile>
<div class="code_container">
<pre class="brush: plain; gutter: false; toolbar: false">
|-- MIT-LICENSE
|-- README
|-- Rakefile
|-- generators
|   |-- yaffle_definition
|   |   |-- USAGE
|   |   |-- templates
|   |   |   `-- definition.txt
|   |   `-- yaffle_definition_generator.rb
|   |-- yaffle_migration
|   |   |-- USAGE
|   |   |-- templates
|   |   `-- yaffle_migration_generator.rb
|   `-- yaffle_route
|       |-- USAGE
|       |-- templates
|       `-- yaffle_route_generator.rb
|-- install.rb
|-- lib
|   |-- app
|   |   |-- controllers
|   |   |   `-- woodpeckers_controller.rb
|   |   |-- helpers
|   |   |   `-- woodpeckers_helper.rb
|   |   `-- models
|   |       `-- woodpecker.rb
|   |-- db
|   |   `-- migrate
|   |       `-- 20081116181115_create_birdhouses.rb
|   |-- yaffle
|   |   |-- acts_as_yaffle.rb
|   |   |-- commands.rb
|   |   |-- core_ext.rb
|   |   `-- routing.rb
|   `-- yaffle.rb
|-- pkg
|   `-- yaffle-0.0.1.gem
|-- rails
|   `-- init.rb
|-- tasks
|   `-- yaffle_tasks.rake
|-- test
|   |-- acts_as_yaffle_test.rb
|   |-- core_ext_test.rb
|   |-- database.yml
|   |-- debug.log
|   |-- definition_generator_test.rb
|   |-- migration_generator_test.rb
|   |-- route_generator_test.rb
|   |-- routes_test.rb
|   |-- schema.rb
|   |-- test_helper.rb
|   |-- woodpecker_test.rb
|   |-- woodpeckers_controller_test.rb
|   |-- wookpeckers_helper_test.rb
|   |-- yaffle_plugin.sqlite3.db
|   `-- yaffle_test.rb
`-- uninstall.rb
</pre>
</div>
</notextile>

<h3 id="changelog">17 Changelog</h3>
<ul>
	<li>April 4, 2010: Fixed document to validate <span class="caps">XHTML</span> 1.0 Strict. <a href="http://jaimeiniesta.com">Jaime Iniesta</a></li>
	<li>November 17, 2008: Major revision by Jeff Dean</li>
</ul>

        <h3>Feedback</h3>
        <p>
          You're encouraged to help in keeping the quality of this guide.
        </p>
        <p>
          If you see any typos or factual errors you are confident to
          patch, please clone <a href="https://github.com/lifo/docrails">docrails</a>
          and push the change yourself. That branch of Rails has public write access.
          Commits are still reviewed, but that happens after you've submitted your
          contribution. <a href="https://github.com/lifo/docrails">docrails</a> is
          cross-merged with master periodically.
        </p>
        <p>
          You may also find incomplete content, or stuff that is not up to date.
          Please do add any missing documentation for master. Check the
          <a href="ruby_on_rails_guides_guidelines.html">Ruby on Rails Guides Guidelines</a>
          for style and conventions.
        </p>
        <p>
          Issues may also be reported in <a href="https://github.com/lifo/docrails/issues">Github</a>.
        </p>
        <p>And last but not least, any kind of discussion regarding Ruby on Rails
          documentation is very welcome in the <a href="http://groups.google.com/group/rubyonrails-docs">rubyonrails-docs mailing list</a>.
        </p>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</p>
      <p>"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.</p>
    </div>
  </div>

  <script type="text/javascript" src="javascripts/guides.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushRuby.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushXml.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushSql.js"></script>
  <script type="text/javascript" src="javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
